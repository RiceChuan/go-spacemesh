// Code generated by MockGen. DO NOT EDIT.
// Source: ./interface.go
//
// Generated by this command:
//
//	mockgen -typed -package=sync2_test -destination=./mocks_test.go -source=./interface.go
//

// Package sync2_test is a generated GoMock package.
package sync2_test

import (
	context "context"
	reflect "reflect"

	types "github.com/spacemeshos/go-spacemesh/common/types"
	p2p "github.com/spacemeshos/go-spacemesh/p2p"
	sync2 "github.com/spacemeshos/go-spacemesh/sync2"
	system "github.com/spacemeshos/go-spacemesh/system"
	gomock "go.uber.org/mock/gomock"
)

// MockFetcher is a mock of Fetcher interface.
type MockFetcher struct {
	ctrl     *gomock.Controller
	recorder *MockFetcherMockRecorder
	isgomock struct{}
}

// MockFetcherMockRecorder is the mock recorder for MockFetcher.
type MockFetcherMockRecorder struct {
	mock *MockFetcher
}

// NewMockFetcher creates a new mock instance.
func NewMockFetcher(ctrl *gomock.Controller) *MockFetcher {
	mock := &MockFetcher{ctrl: ctrl}
	mock.recorder = &MockFetcherMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFetcher) EXPECT() *MockFetcherMockRecorder {
	return m.recorder
}

// GetAtxs mocks base method.
func (m *MockFetcher) GetAtxs(arg0 context.Context, arg1 []types.ATXID, arg2 ...system.GetAtxOpt) error {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetAtxs", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// GetAtxs indicates an expected call of GetAtxs.
func (mr *MockFetcherMockRecorder) GetAtxs(arg0, arg1 any, arg2 ...any) *MockFetcherGetAtxsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAtxs", reflect.TypeOf((*MockFetcher)(nil).GetAtxs), varargs...)
	return &MockFetcherGetAtxsCall{Call: call}
}

// MockFetcherGetAtxsCall wrap *gomock.Call
type MockFetcherGetAtxsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockFetcherGetAtxsCall) Return(arg0 error) *MockFetcherGetAtxsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockFetcherGetAtxsCall) Do(f func(context.Context, []types.ATXID, ...system.GetAtxOpt) error) *MockFetcherGetAtxsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockFetcherGetAtxsCall) DoAndReturn(f func(context.Context, []types.ATXID, ...system.GetAtxOpt) error) *MockFetcherGetAtxsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RegisterPeerHashes mocks base method.
func (m *MockFetcher) RegisterPeerHashes(peer p2p.Peer, hash []types.Hash32) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "RegisterPeerHashes", peer, hash)
}

// RegisterPeerHashes indicates an expected call of RegisterPeerHashes.
func (mr *MockFetcherMockRecorder) RegisterPeerHashes(peer, hash any) *MockFetcherRegisterPeerHashesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterPeerHashes", reflect.TypeOf((*MockFetcher)(nil).RegisterPeerHashes), peer, hash)
	return &MockFetcherRegisterPeerHashesCall{Call: call}
}

// MockFetcherRegisterPeerHashesCall wrap *gomock.Call
type MockFetcherRegisterPeerHashesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockFetcherRegisterPeerHashesCall) Return() *MockFetcherRegisterPeerHashesCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockFetcherRegisterPeerHashesCall) Do(f func(p2p.Peer, []types.Hash32)) *MockFetcherRegisterPeerHashesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockFetcherRegisterPeerHashesCall) DoAndReturn(f func(p2p.Peer, []types.Hash32)) *MockFetcherRegisterPeerHashesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockHashSync is a mock of HashSync interface.
type MockHashSync struct {
	ctrl     *gomock.Controller
	recorder *MockHashSyncMockRecorder
	isgomock struct{}
}

// MockHashSyncMockRecorder is the mock recorder for MockHashSync.
type MockHashSyncMockRecorder struct {
	mock *MockHashSync
}

// NewMockHashSync creates a new mock instance.
func NewMockHashSync(ctrl *gomock.Controller) *MockHashSync {
	mock := &MockHashSync{ctrl: ctrl}
	mock.recorder = &MockHashSyncMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockHashSync) EXPECT() *MockHashSyncMockRecorder {
	return m.recorder
}

// Load mocks base method.
func (m *MockHashSync) Load() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Load")
	ret0, _ := ret[0].(error)
	return ret0
}

// Load indicates an expected call of Load.
func (mr *MockHashSyncMockRecorder) Load() *MockHashSyncLoadCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Load", reflect.TypeOf((*MockHashSync)(nil).Load))
	return &MockHashSyncLoadCall{Call: call}
}

// MockHashSyncLoadCall wrap *gomock.Call
type MockHashSyncLoadCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockHashSyncLoadCall) Return(arg0 error) *MockHashSyncLoadCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockHashSyncLoadCall) Do(f func() error) *MockHashSyncLoadCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockHashSyncLoadCall) DoAndReturn(f func() error) *MockHashSyncLoadCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Start mocks base method.
func (m *MockHashSync) Start() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Start")
}

// Start indicates an expected call of Start.
func (mr *MockHashSyncMockRecorder) Start() *MockHashSyncStartCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockHashSync)(nil).Start))
	return &MockHashSyncStartCall{Call: call}
}

// MockHashSyncStartCall wrap *gomock.Call
type MockHashSyncStartCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockHashSyncStartCall) Return() *MockHashSyncStartCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockHashSyncStartCall) Do(f func()) *MockHashSyncStartCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockHashSyncStartCall) DoAndReturn(f func()) *MockHashSyncStartCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StartAndSync mocks base method.
func (m *MockHashSync) StartAndSync(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StartAndSync", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// StartAndSync indicates an expected call of StartAndSync.
func (mr *MockHashSyncMockRecorder) StartAndSync(ctx any) *MockHashSyncStartAndSyncCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StartAndSync", reflect.TypeOf((*MockHashSync)(nil).StartAndSync), ctx)
	return &MockHashSyncStartAndSyncCall{Call: call}
}

// MockHashSyncStartAndSyncCall wrap *gomock.Call
type MockHashSyncStartAndSyncCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockHashSyncStartAndSyncCall) Return(arg0 error) *MockHashSyncStartAndSyncCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockHashSyncStartAndSyncCall) Do(f func(context.Context) error) *MockHashSyncStartAndSyncCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockHashSyncStartAndSyncCall) DoAndReturn(f func(context.Context) error) *MockHashSyncStartAndSyncCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Stop mocks base method.
func (m *MockHashSync) Stop() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Stop")
}

// Stop indicates an expected call of Stop.
func (mr *MockHashSyncMockRecorder) Stop() *MockHashSyncStopCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockHashSync)(nil).Stop))
	return &MockHashSyncStopCall{Call: call}
}

// MockHashSyncStopCall wrap *gomock.Call
type MockHashSyncStopCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockHashSyncStopCall) Return() *MockHashSyncStopCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockHashSyncStopCall) Do(f func()) *MockHashSyncStopCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockHashSyncStopCall) DoAndReturn(f func()) *MockHashSyncStopCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockHashSyncSource is a mock of HashSyncSource interface.
type MockHashSyncSource struct {
	ctrl     *gomock.Controller
	recorder *MockHashSyncSourceMockRecorder
	isgomock struct{}
}

// MockHashSyncSourceMockRecorder is the mock recorder for MockHashSyncSource.
type MockHashSyncSourceMockRecorder struct {
	mock *MockHashSyncSource
}

// NewMockHashSyncSource creates a new mock instance.
func NewMockHashSyncSource(ctrl *gomock.Controller) *MockHashSyncSource {
	mock := &MockHashSyncSource{ctrl: ctrl}
	mock.recorder = &MockHashSyncSourceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockHashSyncSource) EXPECT() *MockHashSyncSourceMockRecorder {
	return m.recorder
}

// CreateHashSync mocks base method.
func (m *MockHashSyncSource) CreateHashSync(name string, cfg sync2.Config, epoch types.EpochID) (sync2.HashSync, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateHashSync", name, cfg, epoch)
	ret0, _ := ret[0].(sync2.HashSync)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateHashSync indicates an expected call of CreateHashSync.
func (mr *MockHashSyncSourceMockRecorder) CreateHashSync(name, cfg, epoch any) *MockHashSyncSourceCreateHashSyncCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateHashSync", reflect.TypeOf((*MockHashSyncSource)(nil).CreateHashSync), name, cfg, epoch)
	return &MockHashSyncSourceCreateHashSyncCall{Call: call}
}

// MockHashSyncSourceCreateHashSyncCall wrap *gomock.Call
type MockHashSyncSourceCreateHashSyncCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockHashSyncSourceCreateHashSyncCall) Return(arg0 sync2.HashSync, arg1 error) *MockHashSyncSourceCreateHashSyncCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockHashSyncSourceCreateHashSyncCall) Do(f func(string, sync2.Config, types.EpochID) (sync2.HashSync, error)) *MockHashSyncSourceCreateHashSyncCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockHashSyncSourceCreateHashSyncCall) DoAndReturn(f func(string, sync2.Config, types.EpochID) (sync2.HashSync, error)) *MockHashSyncSourceCreateHashSyncCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockLayerTicker is a mock of LayerTicker interface.
type MockLayerTicker struct {
	ctrl     *gomock.Controller
	recorder *MockLayerTickerMockRecorder
	isgomock struct{}
}

// MockLayerTickerMockRecorder is the mock recorder for MockLayerTicker.
type MockLayerTickerMockRecorder struct {
	mock *MockLayerTicker
}

// NewMockLayerTicker creates a new mock instance.
func NewMockLayerTicker(ctrl *gomock.Controller) *MockLayerTicker {
	mock := &MockLayerTicker{ctrl: ctrl}
	mock.recorder = &MockLayerTickerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLayerTicker) EXPECT() *MockLayerTickerMockRecorder {
	return m.recorder
}

// CurrentLayer mocks base method.
func (m *MockLayerTicker) CurrentLayer() types.LayerID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CurrentLayer")
	ret0, _ := ret[0].(types.LayerID)
	return ret0
}

// CurrentLayer indicates an expected call of CurrentLayer.
func (mr *MockLayerTickerMockRecorder) CurrentLayer() *MockLayerTickerCurrentLayerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CurrentLayer", reflect.TypeOf((*MockLayerTicker)(nil).CurrentLayer))
	return &MockLayerTickerCurrentLayerCall{Call: call}
}

// MockLayerTickerCurrentLayerCall wrap *gomock.Call
type MockLayerTickerCurrentLayerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLayerTickerCurrentLayerCall) Return(arg0 types.LayerID) *MockLayerTickerCurrentLayerCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLayerTickerCurrentLayerCall) Do(f func() types.LayerID) *MockLayerTickerCurrentLayerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLayerTickerCurrentLayerCall) DoAndReturn(f func() types.LayerID) *MockLayerTickerCurrentLayerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
